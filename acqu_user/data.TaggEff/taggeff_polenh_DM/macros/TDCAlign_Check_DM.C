Int_t round(Double_t offset_n )
{
  return floor(offset_n  + 0.5 );
}

void TDCAlign_Check_DM(Char_t* taggfile, Char_t* datafile, Int_t outfile = NULL, Int_t xlow = 0.0, Int_t xhigh = 50.0,Int_t pos = 20.0)
{
  // From a detector file find the "Element:" lines and identify the TDCs used
  // for the detector elements. Find the peak position and compare it to the previous
  // calibrated offset and optionally output a new calibration file.
  //
  //Adapted from the original macro of JRMA by DM 7/10/2010 v1.0
  //Update to use pdf and root file output. 10/02/2014 v1.1
  //

  FILE* tfile;                                        // original file pointer
  Char_t line[256];                                   // input line from file
  Char_t desc[32];                                    // general purpose char string
  Char_t* p[16];                                      // parameters read from line
  for(Int_t i=0; i<16; i++) p[i] = new Char_t[16];

  // Open original file
  printf("Checking TDC spectra found in  %s\n",taggfile);
  if( (tfile = fopen(taggfile,"r")) == NULL ){        // open original read only
    printf("File %s open failed\n",taggfile);
    return;
  }

  printf("Opening %s for histograms\n",datafile);    //Added so histogram file can be defined
  TFile* data = new TFile(datafile);
  if( !datafile ){ 
    printf("File %s not found\n", datafile);
    return; 
  }

  //Check to see if an output file is required
  if (outfile){
    string temp = taggfile;
    Char_t taggmod[128];                                // new file to create

    int dpos = temp.find(".dat");
    if(dpos!=-1){
      temp.replace(dpos,4,".realigned.dat");
    }
    else{
      temp.append(".realigned");
    }
    strcpy(taggmod,temp.c_str());

    FILE* mfile;                                        // copy file pointer

    if( (mfile = fopen(taggmod,"w")) == NULL ){         // open copy file for write
      printf("File %s open failed\n",taggmod);
      return;
    }
    fprintf(mfile,"##  Religned-TDC AcquRoot Detector file\n");
    fprintf(mfile,"##  Generated by macro TDCAlign_Check_DM.C, D.M. 07/01/2010\n");

    //Stuff to output a file of the fits
    Char_t plotsfile[50];
    strcpy(plotsfile,datafile);
    strcat(plotsfile,".realigned_fits.pdf");
    TPDF *pdfout = new TPDF(plotsfile,111);             //define an output pdf plots file

    Int_t pgno=0;
    Char_t pagetitle[100];

    Char_t rootfile[50];
    strcpy(rootfile,datafile);
    strcat(rootfile,".realigned_fits.root");
    TFile *rootout = new TFile(rootfile, "RECREATE");  //define an output root histogram file

    TCanvas *canvas = new TCanvas("canvas","Canvas",700,1000);
    canvas->SetFillColor(10);
    canvas->SetBorderSize(2);
    canvas->SetFrameFillColor(10);
    canvas->Divide(4,4);
    Int_t can;
  }

  TH1F* hist;                                         // TDC spectrum
  TAxis* xaxis;                                       // x-axis
  Double_t mean;                                      // mean value of TDC spectrum
  Int_t m;
  Float_t offset_i;
  Float_t offset_n;
  Float_t offset_o = -3500.0;
  Float_t calib;
  TF1 *fit= new TF1("fit","gaus",xlow,xhigh);
  fit->SetLineColor(2);


  //Start the work
  // Read lines from original until EOF
  while( fgets( line, 256, tfile ) ){
    sscanf( line, "%s", desc );                      // get line descriptor
    if( !strcmp( desc, "Element:") ){                // and check if its an element line
      Int_t n = sscanf( line,"%*s%s%s%s%s%s%s%s%s",p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]);
      n += sscanf( line,"%*s%*s%*s%*s%*s%*s%*s%*s%*s%s%s%s%s%s%s%s%s",
		   p[8],p[9],p[10],p[11],p[12],p[13],p[14],p[15] );
      if( n != 16){
	printf("Bad file format\n%s\n",line);
	return;
      }

      sprintf(desc,"FPD_Time%d;1",m); // pull out the TDC spec
      m++;

      hist = (TH1F*)data->Get(desc);        // and search for the TDC histogram
      if( !hist ){
	printf( "%s not found\n", desc );
	return;
      }

      if(outfile){
	if(can==0) {
	  if(pgno>0)
	    pdfout->NewPage();

	  sprintf(pagetitle,"Tagger Section %c",pgno+65);
	  pdfout->SetTitle(pagetitle);

	  pgno++;
	}

	can+=1;
	canvas->cd(can);
      }

      sscanf(line,"%*s%*s%*s%*s%*s%*s%*s%*s%*s%f",&offset_i);
      if(!offset_i){
	offset_i = offset_o;
      }

      sscanf(line,"%*s%*s%*s%*s%*s%*s%*s%*s%*s%*s%f",&calib);
      if(!calib){
	calib = 0.1170;
      }

      fit->SetParameter(1,0); //clear this in case there is no data for a fit

      if(outfile)
	hist->Fit("fit","QR");
      else
	hist->Fit("fit","QRN");

      //Get the mean and then convert it to a channel offset
      mean = fit->GetParameter(1);

      if (mean!=0)offset_n = offset_i + ((mean - pos)/calib);
      else offset_n = offset_i;

      offset_n = round(offset_n);

      if(outfile){
 
	//Draw the histograms
	hist->SetAxisRange(xlow, xhigh);
	hist->SetTitle("");
	hist->SetXTitle("Time [ns]");
	hist->SetYTitle("Counts");
	hist->Draw();
	hist->Write();

	if(can%16==0){
	  canvas->cd();
	  canvas->Update();
	  can=0;
	}

      }
      //Write the information to the new file

      sprintf( p[8],"%d",offset_n);
      // progress message
      printf("Channel: %s: Old offset: %d; New offset: %d; Difference: %d \n",desc,offset_i,offset_n,(offset_n - offset_i));

      if (outfile){
	fprintf(mfile,"%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n", "Element:",
		p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7],
		p[8],p[9],p[10],p[11],p[12],p[13],p[14],p[15] );
      }
    }
    else if (outfile)fputs( line, mfile );    // if not an element line copy it to new file
  }

  // delete any allocated memory and close input and output files 
  for(Int_t i=0; i<16; i++) {delete p[i]};  
  fclose(tfile);
  data->Close();

  if (outfile){
    fclose(mfile);
    pdfout->Close();
    rootout->Close();

    delete pdfout;
    delete canvas;
    delete rootout;
  }



  return;
}
